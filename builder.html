<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol: ARCHITECT (GOD TIER)</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <span class="nav-trigger" onclick="openNav()">&#9776;</span>
    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <a href="index.html">00 // HOME</a>
        <a href="#god-algo">01 // GOD ALGORITHMS</a>
        <a href="#hardware">02 // HARDWARE SYMPATHY</a>
        <a href="#concurrency">03 // CONCURRENCY HELL</a>
        <a href="breaker.html">>> SWITCH TO BREAKER</a>
    </div>

    <div class="container">
        <header>
            <h1>ARCHITECT PROTOCOL</h1>
            <p class="tagline">FORBIDDEN ENGINEERING KNOWLEDGE</p>
        </header>

        <h2 id="god-algo" class="section-title">01 // Probabilistic Structures</h2>

        <details>
            <summary>BLOOM FILTERS (The Magic of "Maybe")</summary>
            <div class="detail-content">
                <p>Gimana cara Google Chrome tau URL ini berbahaya atau enggak tanpa nyimpen database virus 100TB di laptop lu?</p>
                <div class="sub-concept">
                    <h3>Logika Bloom Filter</h3>
                    <p>Struktur data hemat memori yang menjawab: "Apakah data X ada di sini?".</p>
                    <ul>
                        <li>Jawabannya cuma 2: <strong>"Mungkin Ada"</strong> atau <strong>"Pasti Tidak Ada"</strong>.</li>
                        <li>Tidak pernah "False Negative" (Kalau dia bilang ga ada, pasti ga ada).</li>
                        <li>Sangat cepat, cuma butuh beberapa bit per data. Jauh lebih ringan dari Hash Map.</li>
                    </ul>
                </div>
                <div class="code-block">
                    USE CASE: Cek username unik. Cek Bloom Filter dulu (di RAM). Kalau "Pasti Tidak Ada", langsung acc username. Kalau "Mungkin Ada", baru cek Database beneran (Disk). Hemat 90% query DB.
                </div>
            </div>
        </details>

        <details>
            <summary>HYPERLOGLOG (Counting Billions)</summary>
            <div class="detail-content">
                <p>Gimana cara ngitung "Unique Visitors" Facebook yang miliaran tanpa nyimpen IP address (yang butuh PB storage)?</p>
                <p><strong>HyperLogLog</strong> bisa memperkirakan kardinalitas (jumlah unik) data > 1 Miliar dengan error cuma 2%, tapi cuma butuh memori <strong>1.5 Kilobyte</strong>. Ini ilmu sihir matematika statistik.</p>
            </div>
        </details>

        <h2 id="hardware" class="section-title">02 // Hardware Sympathy</h2>

        <details>
            <summary>CPU BRANCH PREDICTION</summary>
            <div class="detail-content">
                <p>Kenapa kode if-else yang diurutkan (sorted) lebih cepat 6x lipat dari yang acak? Karena CPU itu peramal.</p>
                <div class="sub-concept">
                    <h3>Pipeline Hazard</h3>
                    <p>CPU mencoba menebak jalan mana yang akan diambil `if (x > 10)` SEBELUM x dihitung. Jika tebakannya salah, CPU harus membuang semua kerjaan yang udah disiapin (Pipeline Flush). Ini mahal.</p>
                    <p><strong>Tips Dewa:</strong> Di sistem high-frequency trading, hindari `if-else` di dalam loop panas. Gunakan operasi bitwise atau matematika murni (branchless programming).</p>
                </div>
            </div>
        </details>

        <details>
            <summary>FALSE SHARING (The Silent Killer)</summary>
            <div class="detail-content">
                <p>Bug performa paling sulit dideteksi di multithreading.</p>
                <p>Terjadi ketika dua thread di CPU Core berbeda memodifikasi variabel yang *berbeda*, tapi variabel itu berada di <strong>Cache Line</strong> yang sama (biasanya 64 byte).</p>
                <p>Akibatnya? Core A dan Core B saling membatalkan cache satu sama lain (Ping-pong effect). Performa jatuh drastis walau logic kode bener. Solusi: <strong>Memory Padding</strong>.</p>
            </div>
        </details>

        <h2 id="concurrency" class="section-title">03 // Concurrency Hell</h2>

        <details>
            <summary>THUNDERING HERD PROBLEM</summary>
            <div class="detail-content">
                <p>Bayangkan 1000 proses tidur nunggu 1 koneksi database. Saat koneksi tersedia, OS membangunkan <strong>SEMUA</strong> 1000 proses itu.</p>
                <p>Tapi cuma 1 yang dapet koneksi. 999 lainnya balik tidur. Ini buang resource CPU gila-gilaan (Context Switch Storm). Ini masalah klasik di server Linux lama (sebelum epoll) dan desain sistem yang buruk.</p>
            </div>
        </details>
    </div>

    <script>
        function openNav() { document.getElementById("mySidebar").style.width = "320px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
    </script>
</body>
</html>
